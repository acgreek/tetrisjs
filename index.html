<!DOCTYPE html>
<html>
    <head>
    <style>
html,
body {
    width: 100%;
    height: 100%;
    margin: 0;

}
canvas {
    background: #CCC;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;

}
    </style>
    </style>
        <!-- Load the Paper.js library -->
        <script type="text/javascript" src="js/paper-full.js"></script>
        <!-- Load external PaperScript and associate it with myCanvas -->
        <script type="text/paperscript" canvas="myCanvas">
document.getElementById("myCanvas").style.background = 'black';
// Create a Paper.js Path to draw a line into it:
var path = new Path();
// Give the stroke a color
path.strokeColor = 'red';
var x = 300;
var y = 100;
var start = new Point(x, y);
// Move to start and draw a line from there
path.moveTo(start);
// Note the plus operator on Point objects.
// PaperScript does that for us, and much more!
path.lineTo(start + [ 100, -50 ]);
var rotationRate = 3;
var blockWidth = 18; 
var hs = 3;
var vs = 9*2;
var boardMatrix = new Array();

for (var i =0; i < vs; i ++ ) {
   boardMatrix[i] = new Array();
   for (var j =0; j < hs; j ++ ) {
       boardMatrix[i][j] = null;
   }
} 

var gameBoard = new Path.Rectangle(10,1, blockWidth*hs,blockWidth*vs);
gameBoard.fillColor = 'white';
var blist = new Array();
var date = new Date();
var lastTime = date.getTime();

function Piece () {
    this.bstart=0;
    this.bend=4;
}

function Block(x,y) {
    this.x = x;
    this.y = y;
    this.obj = new Path.Rectangle(10+ x*blockWidth,1+ y*blockWidth,blockWidth,blockWidth);
    this.obj.fillColor = 'red';
} 
Block.prototype.moveLeft = function (){
	this.x--;
	this.obj.position.x-=blockWidth;
} 
Block.prototype.moveRight = function (){
	this.x++;
	this.obj.position.x+=blockWidth;
} 
Block.prototype.moveDown= function (){
	this.y++;
	this.obj.position.y+=blockWidth;
} 


function addBlock(x,y) {
    blist.push(new Block(x, y));
}

var curPiece = new Piece();

function buildSquarePiece() {
    blist = new Array();
    addBlock(0,0);
    addBlock(1,0);
    addBlock(1,1);
    addBlock(0,1);
    return curPiece;
}

function buildLogPiece() {
    blist = new Array();
    addBlock(0,0);
    addBlock(0,1);
    addBlock(0,2);
    addBlock(0,3);
    return curPiece;
}

var pieceIdx=0;
function selectPiece() {
   pieceIdx+=1;
   if ((pieceIdx %2) ==0) { 
      return buildLogPiece();
   }
   return buildSquarePiece();
}

var leftIdx= 0 ;
var rightIdx= hs-1 ;

function canMoveHorizontally(curPiece, idx) {
    var mod = 1;
    if (idx == leftIdx)
       mod =-1;
    for (var i = curPiece.bstart; i < curPiece.bend; i++) {
       if (idx== blist[i].x || null != boardMatrix[blist[i].y][blist[i].x+mod]) {
         return false;
       }
    }
    return true;
}

function canMoveLeft(curPiece) {
    return canMoveHorizontally(curPiece, leftIdx);
}
function canMoveRight(curPiece) {
    return canMoveHorizontally(curPiece, rightIdx);
}

function canMoveDown(curPiece) {
    for (var i = curPiece.bstart; i < curPiece.bend; i++) {
       if (vs-1==  blist[i].y || null != boardMatrix[blist[i].y+1][blist[i].x]) {
         return false;
       }
    }
    return true;
}
function movePieceHorrizontal(curPiece, q) {
    for (var i = curPiece.bstart; i < curPiece.bend; i++) {
       q >0  ? blist[i].moveRight() : blist[i].moveLeft();
    }
}
function movePieceDown(curPiece) {
    for (var i = curPiece.bstart; i < curPiece.bend; i++) {
       blist[i].moveDown();
    }
}
var curPiece = buildSquarePiece(blist);

function markBoard(curPiece){
    for (var i = curPiece.bstart; i < curPiece.bend; i++) {
	boardMatrix[blist[i].y][blist[i].x] =blist[i];
	blist[i].obj.fillColor.hue +=15;
    }
}
var garbage =new Array();

function clearCurrentRow(y) {
      for (var x= 0; x < hs; x++) {
         if (null !=boardMatrix[y][x]) {   
          boardMatrix[y][x].obj.remove(); 
          garbage.push(boardMatrix[y][x]);
	  boardMatrix[y][x] =null ;
         }
      } 
}

function movePiecesDown(y) {
   if (y == 0) {
      clearCurrentRow(y);
      return ;
   }
   for (var x= 0; x < hs; x++) {
	boardMatrix[y][x] =boardMatrix[y-1][x];
        if (null != boardMatrix[y][x]) 
           boardMatrix[y][x].moveDown();
        boardMatrix[y-1][x] = null;
   } 
   movePiecesDown(y-1);
} 

function rotateLine() {
//    Each framesetcols, rotate the path by 3 degrees:
    path.rotate(rotationRate);
//    path.fillColor.hue += 1;
}
function isRowComplete(y) {
  for (var x= 0; x < hs; x++) {
     if (null == boardMatrix[y][x] ) 
        return false;
  } 
  return true;
}
function checkForCompleteRow(y) {
   if (y < 0)
     return ;
   if (isRowComplete(y)) {
        clearCurrentRow(y);
	movePiecesDown(y);
	checkForCompleteRow(y);
   }
   else {
	checkForCompleteRow(y-1);
   }
} 
var readKeyTimeout =  0;
function onFrame(event) {
    rotateLine();

    date = new Date();
    var now = date.getTime();

    if (Key.isDown('q')) {
        x =  x-1;
    }
    if (Key.isDown('w')) {
        x =  x+1;
    }
    document.getElementById('xCord').value = x;
    document.getElementById('yCord').value = y;
    start = new Point(x, y);
    path.position = start;

    if (Key.isDown('d')) {
	if (canMoveRight(curPiece) && (now- readKeyTimeout) > 150) { 
	    movePieceHorrizontal(curPiece, blockWidth);
	    readKeyTimeout = now;
	}
    }
    if (Key.isDown('a')) {
	if (canMoveLeft(curPiece) && (now- readKeyTimeout) > 150) {
	    movePieceHorrizontal(curPiece, -blockWidth);
	    readKeyTimeout = now;
	} 
    }
    if (Key.isDown('s')) {
	if (canMoveDown(curPiece) && (now- readKeyTimeout) > 150) {
	    movePieceDown(curPiece);
	    readKeyTimeout = now;
	} 
    }
    if ((now - lastTime) > 1000) {
	if (!canMoveDown(curPiece)) { 
		markBoard(curPiece);
		checkForCompleteRow(vs-1) ;
		curPiece = selectPiece();
        }
        else { 
	    movePieceDown(curPiece);
        }
        lastTime = now;
    }
}
        </script>
    </head>
    <body>
        <canvas id="myCanvas" resize></canvas> </canvas>
	<input id='xCord' size=60> 
	<input id='yCord' size=60> 
    </body>
</html>

